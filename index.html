
<!DOCTYPE html>      
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ワンモーニング人狼</title>
<style>
  html, body{height:100%; overflow:hidden; overscroll-behavior:none;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('ohatop.jpg'); }
  main.joined{ background-image:url('ohamain.jpg'); }

  /* ✅ 追加：カードサイズ統一（他プレイヤー手札 / センター / 自分手札） */
  :root{
    --card-w: 70px;
    --card-h: 120px;
  }

  /* ★ 右上：タイマー（円枠ネイビー/白/黒字） */
  .round-timer{
    position:fixed;
    right:14px;
    top:74px;
    width:64px;height:64px;
    border-radius:50%;
    border:4px solid #0b1f3a;
    background:#fff;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:500;
    box-shadow:0 10px 26px rgba(0,0,0,.18);
    user-select:none;
  }
  .round-timer.visible{display:flex;}
  .round-timer .txt{
    font-weight:900;color:#111;
    font-size:18px;letter-spacing:.5px;
  }
  .round-timer.ended{ opacity:.85; }

  /* =========================
     ★ アナウンスポップ（左→中央で停止→右へ「完全に流れる」）
     ========================= */
  .announce-pop{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-170%,-50%);
    background:rgba(20,20,20,.92);
    color:#fff;
    padding:18px 28px;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:2147483647;
    font-weight:900;
    white-space:nowrap;
    pointer-events:none;
    will-change:transform, opacity;
    font-size:24px;
    opacity:1;
  }
  @keyframes announceSlideLRFullOut{
    0%   { transform:translate(-170%,-50%); opacity:1; }
    28%  { transform:translate(-50%,-50%);  opacity:1; }
    72%  { transform:translate(-50%,-50%);  opacity:1; }
    100% { transform:translate(260%,-50%);  opacity:0; }
  }
  .announce-pop.play{
    animation:announceSlideLRFullOut 2600ms cubic-bezier(.22,.84,.44,1) both;
  }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:red;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* ★ 手札下：役職ガイド（黒ポップ白字） */
  .role-guide-pop{
    width:fit-content;
    max-width:min(420px, calc(100vw - 36px));
    margin:10px auto 0;
    background:rgba(20,20,20,.94);
    color:#fff;
    border-radius:14px;
    padding:10px 12px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    font-size:12px;
    line-height:1.6;
    font-weight:800;
    text-align:left;
    white-space:pre-line;
    pointer-events:none;
  }
  .role-guide-pop.hidden{display:none;}

  /* ★ プレイヤー円配置用 */
  .player-circle{
    position:relative;width:260px;height:260px;
    margin:8px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ★ 投票済プレイヤー：黒塗白字（自分が投票済の時に適用） */
  .player-tag.voted-dim{
    background:#111 !important;
    color:#fff !important;
    border-color:#111 !important;
  }

  /* ★ 封筒バッジ（ネームタグの上に表示） */
  .envelope-badge{
    position:absolute;
    left:50%;
    top:-18px;
    transform:translateX(-50%);
    font-weight:900;
    font-size:16px;
    line-height:1;
    white-space:nowrap;
    color:#111;
    text-shadow:
      0 0 2px rgba(255,255,255,.95),
      0 2px 8px rgba(0,0,0,.25);
    pointer-events:none;
  }

  /* =========================
     ★ カード：影なし（大小パルス時も含む）
     ========================= */
  .center-card,
  .mini-card,
  .my-card,
  .help-card,
  .vote-result-card{
    box-shadow:none !important;
    filter:none !important;
  }

  /* =========================
     ✅ 画像が「切れる」対策（自分/ヘルプ）
     ========================= */
  .my-card,
  .help-card{
    overflow:visible !important;
    box-sizing:border-box;
  }
  .help-card{
    padding:2px;
  }
  .my-card img{
    width:92% !important;
    height:100% !important;
    object-fit:contain !important;
    object-position:center !important;
    display:block;
  }
  .help-card img{
    width:100% !important;
    height:100% !important;
    object-fit:contain !important;
    object-position:center !important;
    display:block;
  }

  /* =========================
     ★ 「全体公開」した瞬間：ちょいバウンド（既存）
     ========================= */
  @keyframes revealBounce{
    0%   { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(1); }
    45%  { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(1.18); }
    75%  { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(0.98); }
    100% { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(1); }
  }
  .mini-card.reveal-bounce{
    animation:revealBounce 420ms cubic-bezier(.22,.84,.44,1) both;
  }

  @keyframes revealBounceMy{
    0%   { transform: scale(1); }
    45%  { transform: scale(1.14); }
    75%  { transform: scale(0.98); }
    100% { transform: scale(1); }
  }
  .my-card.reveal-bounce{
    animation:revealBounceMy 420ms cubic-bezier(.22,.84,.44,1) both;
  }

  /* =========================
     ✅ 今回追加：きつね/ろしゅつきょう 公開時の「バウンド強め」
     ========================= */
  @keyframes globalRevealBounceMini{
    0%   { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(1); }
    40%  { transform: translate(-50%,-2px) rotate(var(--rot,0deg)) scale(1.28); }
    70%  { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(0.96); }
    100% { transform: translate(-50%,0) rotate(var(--rot,0deg)) scale(1); }
  }
  .mini-card.global-reveal-bounce{
    animation:globalRevealBounceMini 520ms cubic-bezier(.22,.84,.44,1) both;
  }

  @keyframes globalRevealBounceMy{
    0%   { transform: scale(1); }
    40%  { transform: translateY(-2px) scale(1.22); }
    70%  { transform: translateY(0) scale(0.97); }
    100% { transform: translateY(0) scale(1); }
  }
  .my-card.global-reveal-bounce{
    animation:globalRevealBounceMy 520ms cubic-bezier(.22,.84,.44,1) both;
  }

  /* =========================
     ✅ 修正：点線赤枠の「ズレ」対策
     ========================= */
  .my-card{ position:relative; }
  .my-card.public-revealed-outline{ outline:none; }
  .my-card.public-revealed-outline::after{
    content:'';
    position:absolute;
    inset:-3px;
    border:3px dashed #ef4444;
    border-radius:inherit;
    pointer-events:none;
    box-sizing:border-box;
  }

  /* =========================
     ★ センター3枚（横並び）
     ========================= */
  .center-cards{
    position:absolute;left:50%;top:70%;
    transform:translate(-50%,-50%);
    display:flex;gap:0px;align-items:center;justify-content:center;
    z-index:5;
    pointer-events:none;
  }
  .center-card{
    width:var(--card-w);
    height:var(--card-h);
    border-radius:12px;
    border:none;
    background:transparent;
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
  }
  .center-card img{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    display:block;
  }
  .center-cards.selectable{ pointer-events:auto; }
  .center-cards.selectable .center-card{ cursor:pointer; }
  .center-cards.selectable .center-card:hover{
    outline:2px solid rgba(0,0,0,.12);
    outline-offset:2px;
  }
  @keyframes pulseScale {
    0%   { transform:scale(1); }
    50%  { transform:scale(1.12); }
    100% { transform:scale(1); }
  }
  .center-cards.reibai-pulsing .center-card{ animation:pulseScale .9s ease-in-out infinite; }
  .center-cards.reibai-pulsing .center-card:nth-child(2){ animation-delay:.08s; }
  .center-cards.reibai-pulsing .center-card:nth-child(3){ animation-delay:.16s; }

  /* =========================
     ★ 他プレイヤー扇上手札（サイズ統一 90:120）
     ========================= */
  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,6px);
    width:300px;height:140px;
    pointer-events:none;
  }
  .player-tag.goei-selectable .mini-hand{ pointer-events:auto; }
  .player-tag.uranai-selectable .mini-hand{ pointer-events:auto; }
  .player-tag.vote-selectable .mini-hand{ pointer-events:auto; }

  .player-tag.goei-selectable .mini-card{ cursor:pointer; }
  .player-tag.uranai-selectable .mini-card{ cursor:pointer; }
  .player-tag.vote-selectable .mini-card{ cursor:pointer; }

  .player-tag.goei-selectable .mini-card:hover,
  .player-tag.uranai-selectable .mini-card:hover,
  .player-tag.vote-selectable .mini-card:hover{
    outline:2px solid rgba(0,0,0,.12);
    outline-offset:2px;
  }

  .mini-card{
    position:absolute;left:50%;top:0;
    width:var(--card-w);
    height:var(--card-h);
    border-radius:12px;
    transform-origin:bottom center;
    border:none;
    background:transparent;
    overflow:hidden;

    --rot: 0deg;
    transform: translate(-50%,0) rotate(var(--rot)) scale(1);
    will-change: transform;
  }
  .mini-card img{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    display:block;
  }

  @keyframes miniPulseRole {
    0%   { transform: translate(-50%,0) rotate(var(--rot)) scale(1); }
    50%  { transform: translate(-50%,0) rotate(var(--rot)) scale(1.12); }
    100% { transform: translate(-50%,0) rotate(var(--rot)) scale(1); }
  }
  @keyframes miniPulseVote {
    0%   { transform: translate(-50%,0) rotate(var(--rot)) scale(1); }
    50%  { transform: translate(-50%,0) rotate(var(--rot)) scale(1.12); }
    100% { transform: translate(-50%,0) rotate(var(--rot)) scale(1); }
  }

  .player-tag.goei-pulsing .mini-card{ animation:miniPulseRole .9s ease-in-out infinite; }
  .player-tag.goei-pulsing .mini-card:nth-child(2){ animation-delay:.08s; }
  .player-tag.goei-pulsing .mini-card:nth-child(3){ animation-delay:.16s; }

  .player-tag.uranai-pulsing .mini-card{ animation:miniPulseRole .9s ease-in-out infinite; }
  .player-tag.uranai-pulsing .mini-card:nth-child(2){ animation-delay:.08s; }
  .player-tag.uranai-pulsing .mini-card:nth-child(3){ animation-delay:.16s; }

  .player-tag.vote-pulsing .mini-card{ animation:miniPulseVote .85s ease-in-out infinite; }
  .player-tag.vote-pulsing .mini-card:nth-child(2){ animation-delay:.07s; }
  .player-tag.vote-pulsing .mini-card:nth-child(3){ animation-delay:.14s; }

  /* 自分の手札 */
  .my-hand-wrapper{margin-top:40px;text-align:center; position:relative;}
  .my-hand-title{display:none;}
  .my-hand{
    display:flex;
    justify-content:center;
    gap:8px;
    margin-top:18px;
    min-height:calc(var(--card-h) + 10px);
    flex-wrap:wrap;
  }
  .my-card{
    width:var(--card-w);
    height:var(--card-h);
    border-radius:12px;
    border:none;
    background:transparent;
    cursor:pointer;
    user-select:none;
    display:grid;
    place-items:center;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* ★ 左下「？」 */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{
    padding:12px;
    overflow:auto;
    max-height:calc(70vh - 48px);
  }

  /* ✅ ヘルプのカードを「5枚横並び」 */
  .help-grid{
    display:grid;
    grid-template-columns:repeat(5, minmax(0, 1fr));
    gap:10px;
    align-items:start;
  }
  .help-card{
    width:100%;
    aspect-ratio: 2 / 3;
    border-radius:12px;
    border:none;
    background:transparent;
    display:grid;
    place-items:center;
    user-select:none;
    min-width:0;
    position:relative; /* ✅ タグ用 */
  }
  .help-card img{
    width:100% !important;
    height:100% !important;
    object-fit:contain !important;
    display:block;
  }

  /* ✅ 追加：デッキに入らないカードは薄く */
  .help-card.dim{
    opacity:.28;
    filter:grayscale(1);
  }
  .help-card.host-toggle{
    cursor:pointer;
  }
  .help-card.host-toggle:hover{
    outline:2px solid rgba(0,0,0,.12);
    outline-offset:2px;
  }

  /* ✅ 追加：枚数タグ（右上） */
  .count-badge{
    position:absolute;
    right:6px;
    top:6px;
    min-width:22px;
    height:22px;
    padding:0 6px;
    border-radius:999px;
    background:rgba(17,17,17,.92);
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-size:12px;
    line-height:1;
    box-shadow:0 10px 20px rgba(0,0,0,.18);
    pointer-events:none;
  }

  /* ✅ 追加：説明欄（カード一覧の下） */
  .help-desc{
    background:#f3f4f6;
    border:1px solid #cbd5e1;
    border-radius:12px;
    padding:8px 10px;
    font-size:12px;
    line-height:1.45;
    font-weight:900;
    color:#111;
    box-shadow:0 10px 20px rgba(0,0,0,.08);
    min-width:0;
    white-space:pre-line;
  }
  .help-desc .sub{
    display:block;
    margin-top:4px;
    font-weight:800;
    opacity:.85;
  }

  /* ★ ヘルプ右下に「タイマー設定カード」 */
  .help-card.timer-card{
    background:#fff;
    border-radius:12px;
    padding:10px;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:space-between;
    gap:8px;
  }
  .help-card.timer-card .timer-title{
    font-weight:900;
    font-size:12px;
    text-align:center;
    line-height:1.2;
    color:#111;
  }
  .help-card.timer-card .timer-buttons{
    display:grid;
    grid-template-columns:1fr;
    gap:8px;
  }
  .help-card.timer-card .tbtn{
    appearance:none;
    border:1px solid #111;
    background:#111;
    color:#fff;
    border-radius:10px;
    padding:8px 8px;
    font-weight:900;
    font-size:12px;
    cursor:pointer;
    user-select:none;
    line-height:1;
  }
  .help-card.timer-card .tbtn:hover{ filter:brightness(1.05); }
  .help-card.timer-card .tbtn:active{ transform:translateY(1px); }
  .help-card.timer-card .timer-selected{
    outline:2px solid rgba(0,0,0,.18);
    outline-offset:2px;
  }
  .help-card.timer-card .timer-note{
    font-size:11px;
    font-weight:800;
    opacity:.75;
    text-align:center;
  }

  /* ★ 役職選択ポップ */
  .role-picker-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;
    z-index:320;
  }
  .role-picker-backdrop.hidden{display:none;}
  .role-picker{
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    padding:14px 14px 12px;
    min-width:min(360px, calc(100% - 48px));
    max-width:420px;
  }
  .role-picker-title{font-weight:900;font-size:14px;margin:0 0 10px;}
  .role-picker-actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;}
  .role-btn{
    padding:10px 14px;border-radius:999px;border:1px solid #111;background:#111;color:#fff;
    font-weight:900;cursor:pointer;user-select:none;
    min-width:110px;text-align:center;
  }
  .role-btn.ghost{background:#fff;color:#111;border-color:#ddd;}
  .role-btn.disabled{
    background:#9ca3af !important;
    border-color:#9ca3af !important;
    color:#fff !important;
    cursor:not-allowed !important;
    opacity:1 !important;
    pointer-events:none !important;
  }
  .role-picker-foot{display:flex;justify-content:flex-end;margin-top:10px;}

  /* ★ 吹き出し */
  .bubble{
    position:absolute;
    left:50%;
    bottom:calc(100% + 8px);
    transform:translateX(-50%);
    background:rgba(20,20,20,.92);
    color:#fff;
    font-size:12px;
    font-weight:900;
    padding:6px 10px;
    border-radius:999px;
    white-space:nowrap;
    box-shadow:0 10px 26px rgba(0,0,0,.25);
    pointer-events:none;
  }
  .bubble::after{
    content:'';
    position:absolute;
    left:50%;
    bottom:-6px;
    transform:translateX(-50%);
    width:0;height:0;
    border-left:6px solid transparent;
    border-right:6px solid transparent;
    border-top:6px solid rgba(20,20,20,.92);
  }

  /* ★ グローバル矢印レイヤ */
  .global-arrow-layer{
    position:fixed;inset:0;
    z-index:260;
    pointer-events:none;
  }

  /* =========================
     ★ 最多票カード 拡大表示（2秒表示）＋画像が切れない
     ========================= */
  .vote-result-overlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:2147483646;
    pointer-events:none;
  }
  .vote-result-overlay.visible{ display:flex; }

  .vote-result-row{
    display:flex;
    gap:14px;
    flex-wrap:nowrap;
    align-items:center;
    justify-content:center;
    padding:10px 14px;
    max-width:calc(100vw - 24px);
    overflow:visible;
  }

  .vote-result-card{
    width:min(140px, 22vw);
    aspect-ratio: 2 / 3;
    height:auto;
    border-radius:16px;
    overflow:visible;
    background:transparent;
    display:grid;
    place-items:center;
    transform-origin:center;
    will-change:transform;
    animation:shakeTiny 250ms ease-in-out 2;
  }
  .vote-result-card img{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    display:block;
    border-radius:16px;
  }

  .card-loss-wrap{
    position:relative;
    display:grid;
    place-items:center;
    width:100%;
    height:100%;
    overflow:hidden;
    border-radius:inherit;
  }
  .card-loss-wrap > img{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    display:block;
    transform:none !important;
  }
  .card-loss-wrap .loss-crack{
    position:absolute;
    inset:0;
    pointer-events:none;
    z-index:3;

  }
  .card-loss-wrap > img:last-child,
  .card-loss-wrap > .card-image{
    position:relative;
    z-index:1;
  }

  @keyframes shakeTiny{
    0%   { transform:translateX(0) rotate(0deg) scale(1.02); }
    25%  { transform:translateX(-2px) rotate(-1deg) scale(1.02); }
    50%  { transform:translateX(2px) rotate(1deg) scale(1.02); }
    75%  { transform:translateX(-1px) rotate(0.5deg) scale(1.02); }
    100% { transform:translateX(0) rotate(0deg) scale(1.02); }
  }

  /* 投票後の他プレイヤーカード（mini-card）では固定サイズで表示して拡大を防ぐ */
  .mini-card > .card-loss-wrap{
    position:absolute;
    inset:0;
    width:var(--card-w);
    height:var(--card-h);
  }
  .mini-card > .card-loss-wrap > img{
    width:var(--card-w);
    height:var(--card-h);
    max-width:var(--card-w);
    max-height:var(--card-h);
  }


</style>
</head>
<body>

<header>
  <h1>ワンモーニング人狼</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<!-- ★ 右上タイマー -->
<div id="roundTimer" class="round-timer" aria-label="タイマー">
  <div id="roundTimerText" class="txt">2:00</div>
</div>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle"></div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>

    <div id="roleGuidePop" class="role-guide-pop hidden" aria-hidden="true">うらないし：COしていないプレイヤーのカードを見る。
れいばいし：真ん中のカードを1枚見る。
　ごえい　：COしたプレイヤーのカードを見る。</div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で山札からランダムに<br>
    ① 全プレイヤーへ1枚ずつ配布<br>
    ② センターに3枚（横並び）を表示（※裏向き）<br>
    ③ 右上にタイマーを表示してカウントダウン開始<br>
    ④ タイマー0→投票ポップ→消えたら投票開始
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="rolePickerBackdrop" class="role-picker-backdrop hidden">
  <div class="role-picker" role="dialog" aria-modal="true" aria-label="役職選択">
    <p class="role-picker-title">役職を選択</p>
    <div class="role-picker-actions">
      <button class="role-btn" data-role="うらないし">うらないし</button>
      <button class="role-btn" data-role="れいばいし">れいばいし</button>
      <button class="role-btn" data-role="ごえい">ごえい</button>
    </div>
    <div class="role-picker-foot">
      <button id="btnRoleCancel" class="btn ghost" style="padding:6px 10px;font-size:12px;">キャンセル</button>
    </div>
  </div>
</div>

<svg id="globalArrowLayer" class="global-arrow-layer"></svg>

<!-- ★ 最多票カードの拡大表示 -->
<div id="voteResultOverlay" class="vote-result-overlay" aria-hidden="true">
  <div id="voteResultRow" class="vote-result-row"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  bubbles: {},
  reibaishiPicks: {},
  goeiPicks: {},
  uranaishiPicks: {},
  timer: null,
  timerConfig: null,
  votes: {},
  publicReveals: {},
  deckOverrides: {},

  // ✅ 追加：「みてはいけないもの」センター公開情報
  centerPublic: null,
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const roleGuidePop = document.getElementById('roleGuidePop');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const rolePickerBackdrop = document.getElementById('rolePickerBackdrop');
const btnRoleCancel = document.getElementById('btnRoleCancel');

const globalArrowLayer = document.getElementById('globalArrowLayer');

const voteResultOverlay = document.getElementById('voteResultOverlay');
const voteResultRow = document.getElementById('voteResultRow');

let timerTickId = null;
let announceEl = null;
let lastStartedAtSeen = null;
let voteAnnouncedForStartAt = null;

const VOTE_POP_MS = 2600;
let voteOpenTimerId = null;
let lastVoteDoneAtSeen = null;

const revealBounceSeen = {};
const globalSpecialBounceSeen = {};
const myPublicOutlineSeen = {};

const GLOBAL_REVEAL_CARDS = new Set(['きつね','ろしゅつきょう']);

// ✅ 追加：「みてはいけないもの」定数
const FORBIDDEN_CARD_NAME = 'みてはいけないもの';
let forbiddenAnnouncedAtSeen = null;

function showAnnounce(text){
  if (announceEl && announceEl.parentNode) announceEl.parentNode.removeChild(announceEl);
  const el = document.createElement('div');
  el.className = 'announce-pop';
  el.textContent = text;
  document.body.appendChild(el);
  announceEl = el;
  void el.offsetWidth;
  el.classList.add('play');
  el.addEventListener('animationend', () => {
    if (el.parentNode) el.parentNode.removeChild(el);
    if (announceEl === el) announceEl = null;
  }, { once:true });
}

/* ===== 画像ユーティリティ：カード名.png ===== */
const BACK_IMAGE = 'ohaback.png';
function safeFilePart(name){ return encodeURIComponent(String(name)); }
function cardImgSrcByName(cardName){ return `${safeFilePart(cardName)}.png`; }
function buildCardImg(src, alt=''){
  const img = document.createElement('img');
  img.alt = alt;
  img.src = src;
  img.draggable = false;
  img.loading = 'lazy';
  return img;
}

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];
let rolePickerOpen = false;

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

/* ===== 右上タイマー ===== */
function pad2(n){ return String(n).padStart(2,'0'); }
function formatMMSS(totalSec){
  const s = Math.max(0, Math.floor(totalSec));
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${m}:${pad2(r)}`;
}
function stopTimerTick(){
  if (timerTickId) { cancelAnimationFrame(timerTickId); timerTickId = null; }
}
function clearVoteOpenSchedule(){
  if (voteOpenTimerId){ clearTimeout(voteOpenTimerId); voteOpenTimerId = null; }
}
function scheduleVoteOpenIfNeeded(){
  clearVoteOpenSchedule();
  const t = state.timer;
  if (!t || !t.startAt || !t.durationSec) return;

  const startAt = Number(t.startAt);
  const durationSec = Number(t.durationSec);
  const voteOpenAt = startAt + durationSec*1000 + VOTE_POP_MS;
  const now = Date.now();
  const ms = Math.max(0, voteOpenAt - now);

  voteOpenTimerId = setTimeout(() => {
    if (latestPlayers.length) renderAll(latestPlayers);
  }, ms);
}
function renderTimerByNow(){
  stopTimerTick();

  const roundTimerEl = document.getElementById('roundTimer');
  const roundTimerTextEl = document.getElementById('roundTimerText');

  if (!state.timer || !state.timer.startAt || !state.timer.durationSec){
    roundTimerEl.classList.remove('visible');
    roundTimerEl.classList.remove('ended');
    const fallback = state.timerConfig?.durationSec ?? 120;
    roundTimerTextEl.textContent = formatMMSS(fallback);
    return;
  }

  roundTimerEl.classList.add('visible');
  roundTimerEl.classList.remove('ended');

  const startAt = Number(state.timer.startAt);
  const durationSec = Number(state.timer.durationSec);

  const tick = () => {
    const now = Date.now();
    const elapsedSec = (now - startAt) / 1000;
    const remain = Math.max(0, durationSec - elapsedSec);

    roundTimerTextEl.textContent = formatMMSS(remain);

    if (remain <= 0){
      roundTimerEl.classList.add('ended');

      if (voteAnnouncedForStartAt !== startAt){
        voteAnnouncedForStartAt = startAt;
        showAnnounce('投票！');
        scheduleVoteOpenIfNeeded();
      }

      stopTimerTick();
      return;
    }

    timerTickId = requestAnimationFrame(tick);
  };
  tick();
}
function subscribeTimer(){
  onValue(ref(db, `rooms/${state.roomCode}/timer`), snap => {
    state.timer = snap.val() || null;
    renderTimerByNow();
    scheduleVoteOpenIfNeeded();
  });
}

/* ===== タイマー設定（ヘルプ右下） ===== */
function subscribeTimerConfig(){
  onValue(ref(db, `rooms/${state.roomCode}/timerConfig`), snap => {
    state.timerConfig = snap.val() || null;
    renderTimerByNow();
    syncHelpTimerSelectionUI();
  });
}
async function setTimerDurationSec(sec){
  if (!state.roomCode || !state.isHost) return;
  await set(ref(db, `rooms/${state.roomCode}/timerConfig`), {
    durationSec: Number(sec),
    updatedAt: Date.now(),
    updatedBy: state.userId
  });
}
function getConfiguredDurationSec(){
  const v = state.timerConfig?.durationSec;
  return (Number.isFinite(v) && v > 0) ? Number(v) : 120;
}
function syncHelpTimerSelectionUI(){
  const card = helpBody.querySelector?.('.help-card.timer-card');
  if (!card) return;
  const sec = getConfiguredDurationSec();
  card.querySelectorAll('[data-timer-sec]').forEach(btn => {
    const s = Number(btn.getAttribute('data-timer-sec'));
    btn.classList.toggle('timer-selected', s === sec);
  });
}
async function startConfiguredTimer(){
  const durationSec = getConfiguredDurationSec();
  const base = `rooms/${state.roomCode}`;
  await set(ref(db, `${base}/timer`), {
    startAt: Date.now(),
    durationSec
  });
}

/* ======================================================
   ✅ デッキ構成（人数別プリセット）＋ホスト上書き
   ====================================================== */

const VARIABLE_COUNT_CARDS = new Set(['むらびと','おおかみ']);

/* すべてのカード（ユニーク） */
const ALL_CARDS = [
  'むらびと',
  'うらないし',
  'れいばいし',
  'ごえい',
  'うし',
  'おおかみ',
  'きょうじん',
  'みてはいけないもの',
  'きつね',
  'ろしゅつきょう',
];

const DECK_PRESETS = {
  3: {
    'おおかみ':1, 'きょうじん':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,
    'ろしゅつきょう':1
  },
  4: {
    'おおかみ':1, 'きょうじん':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,
    'きつね':1,
    'ろしゅつきょう':1
  },
  5: {
    'おおかみ':2, 'みてはいけないもの':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,
    'きつね':1,
    'ろしゅつきょう':1
  },
  6: {
    'おおかみ':2, 'みてはいけないもの':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,
    'きつね':1,
    'ろしゅつきょう':1, 'うし':1
  },
  7: {
    'おおかみ':3, 'みてはいけないもの':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,'むらびと':1,
    'きつね':1,
    'ろしゅつきょう':1
  },
  8: {
    'おおかみ':3, 'みてはいけないもの':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,
    'きつね':1,
    'ろしゅつきょう':1, 'うし':1
  },
  9: {
    'おおかみ':3, 'みてはいけないもの':1, 'きょうじん':1,
    'うらないし':1,'れいばいし':1,'ごえい':1,'むらびと':1,
    'きつね':1,
    'ろしゅつきょう':1, 'うし':1
  },
};

const MANUAL_ADD_COUNT = {
  'むらびと':1,
  'うらないし':1,
  'れいばいし':1,
  'ごえい':1,
  'おおかみ':1,
  'きょうじん':1,
  'みてはいけないもの':1,
  'きつね':1,
  'ろしゅつきょう':1,
  'うし':1,
};

function clampInt(n, min, max){
  const x = Number(n);
  if (!Number.isFinite(x)) return min;
  const v = Math.floor(x);
  return Math.max(min, Math.min(max, v));
}

function getCurrentPlayerCount(){
  const n = Number(state.room?.maxPlayers ?? 0);
  return Number.isFinite(n) ? n : 0;
}
function getPresetCountsFor(n){
  const v = DECK_PRESETS[n];
  return v ? v : {};
}

function computeEffectiveCount(cardName, presetCounts, overrides){
  const base = Number(presetCounts?.[cardName] ?? 0);
  const ov  = overrides && (cardName in overrides) ? overrides[cardName] : undefined;

  if (typeof ov === 'number'){
    if (VARIABLE_COUNT_CARDS.has(String(cardName))){
      return clampInt(ov, 0, 3);
    }
    return Math.max(0, Math.floor(ov));
  }

  if (ov === false) return 0;
  if (ov === true){
    if (base > 0) return base;
    return Number(MANUAL_ADD_COUNT[cardName] ?? 1);
  }
  return base;
}
function getEffectiveCountNow(cardName){
  const n = getCurrentPlayerCount();
  const preset = getPresetCountsFor(n);
  return computeEffectiveCount(cardName, preset, state.deckOverrides);
}
function isCardEnabledNow(cardName){
  return getEffectiveCountNow(cardName) > 0;
}

function subscribeDeckOverrides(){
  onValue(ref(db, `rooms/${state.roomCode}/deckOverrides`), snap => {
    state.deckOverrides = snap.val() || {};
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}
async function setDeckOverride(cardName, value){
  if (!state.roomCode) return;
  await set(ref(db, `rooms/${state.roomCode}/deckOverrides/${cardName}`), value);
}

function expandDeckFromCounts(countsObj){
  const arr = [];
  for (const name of ALL_CARDS){
    const c = Number(countsObj?.[name] ?? 0);
    for(let i=0;i<c;i++) arr.push(name);
  }
  return arr;
}
function buildDeck(){
  const n = getCurrentPlayerCount();
  const preset = getPresetCountsFor(n);

  const effectiveCounts = {};
  for (const name of ALL_CARDS){
    effectiveCounts[name] = computeEffectiveCount(name, preset, state.deckOverrides);
  }
  return expandDeckFromCounts(effectiveCounts);
}

function cryptoRandInt(maxExclusive){
  if (maxExclusive <= 0) return 0;
  const a = new Uint32Array(1);
  crypto.getRandomValues(a);
  return a[0] % maxExclusive;
}
function shuffleInPlace(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = cryptoRandInt(i+1);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const data = snap.val() || {};
  let mySeatIndex = null;
  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) { mySeatIndex = Number(seatIndex); break; }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost) hostSettingsBtn.classList.add('visible');
  else { hostSettingsBtn.classList.remove('visible'); startPop.classList.add('hidden'); }
  helpBtn.classList.add('visible');
}

function updateRoleGuidePopVisibility(){
  const isJoined = joinBox.classList.contains('hidden');
  roleGuidePop.classList.toggle('hidden', !isJoined);
}

/* ===== bubbles ===== */
function subscribeBubbles(){
  onValue(ref(db, `rooms/${state.roomCode}/bubbles`), snap => {
    state.bubbles = snap.val() || {};
    if (latestPlayers.length) renderAll(latestPlayers);
  });
}
async function setMyBubble(text){
  if (!state.roomCode) return;
  await set(ref(db, `rooms/${state.roomCode}/bubbles/${state.userId}`), { text, updatedAt: Date.now() });
}

/* ===== れいばいし ===== */
function subscribeReibaishiPicks(){
  onValue(ref(db, `rooms/${state.roomCode}/reibaishiPicks`), snap => {
    state.reibaishiPicks = snap.val() || {};
    if (latestPlayers.length) renderAll(latestPlayers);
  });
}
async function setMyReibaishiPick(index){
  if (!state.roomCode) return;
  const pickedAt = Date.now();
  await set(ref(db, `rooms/${state.roomCode}/reibaishiPicks/${state.userId}`), { index, pickedAt });

  // ✅ 追加：見たカードが「みてはいけないもの」なら全体公開＋タイマーを残り1秒に
  await maybeTriggerForbiddenCenter(index);
}

/* ===== ごえい ===== */
function subscribeGoeiPicks(){
  onValue(ref(db, `rooms/${state.roomCode}/goeiPicks`), snap => {
    state.goeiPicks = snap.val() || {};
    if (latestPlayers.length) renderAll(latestPlayers);
  });
}
async function setMyGoeiPick(targetPlayerId){
  if (!state.roomCode) return;
  await set(ref(db, `rooms/${state.roomCode}/goeiPicks/${state.userId}`), { targetPlayerId, pickedAt: Date.now() });
  await maybePublishGlobalRevealFromSeeing(targetPlayerId);
}

/* ===== うらないし ===== */
function subscribeUranaishiPicks(){
  onValue(ref(db, `rooms/${state.roomCode}/uranaishiPicks`), snap => {
    state.uranaishiPicks = snap.val() || {};
    if (latestPlayers.length) renderAll(latestPlayers);
  });
}
async function setMyUranaishiPick(targetPlayerId){
  if (!state.roomCode) return;
  await set(ref(db, `rooms/${state.roomCode}/uranaishiPicks/${state.userId}`), { targetPlayerId, pickedAt: Date.now() });
  await maybePublishGlobalRevealFromSeeing(targetPlayerId);
}

/* ===== 全体公開 ===== */
function subscribePublicReveals(){
  onValue(ref(db, `rooms/${state.roomCode}/publicReveals`), snap => {
    state.publicReveals = snap.val() || {};
    if (latestPlayers.length) renderAll(latestPlayers);
  });
}
function getPublicRevealFor(playerId){
  const r = state.publicReveals && state.publicReveals[playerId];
  if (!r || !r.cardName || !r.revealedAt) return null;
  return r;
}
async function publishPublicReveal(targetPlayerId, cardName){
  if (!state.roomCode) return;
  if (!targetPlayerId) return;
  if (!cardName) return;
  if (!GLOBAL_REVEAL_CARDS.has(String(cardName))) return;

  const now = Date.now();
  await set(ref(db, `rooms/${state.roomCode}/publicReveals/${targetPlayerId}`), {
    cardName: String(cardName),
    revealedAt: now,
    byPlayerId: state.userId
  });
}
async function maybePublishGlobalRevealFromSeeing(targetPlayerId){
  const hand = state.hands && state.hands[String(targetPlayerId)];
  const cardName = (hand && Array.isArray(hand.cards) && hand.cards[0]) ? String(hand.cards[0]) : null;
  if (!cardName) return;
  if (!GLOBAL_REVEAL_CARDS.has(cardName)) return;

  const existing = getPublicRevealFor(String(targetPlayerId));
  if (existing && String(existing.cardName) === cardName) return;

  await publishPublicReveal(String(targetPlayerId), cardName);
}

/* =========================================
   ✅ 追加：センター「みてはいけないもの」全体公開＋タイマー残り1秒
   ========================================= */
function subscribeCenterPublic(){
  onValue(ref(db, `rooms/${state.roomCode}/centerPublic`), snap => {
    state.centerPublic = snap.val() || null;

    // 1回だけアナウンス
    const cp = state.centerPublic;
    if (cp && cp.cardName === FORBIDDEN_CARD_NAME && cp.revealedAt){
      const at = Number(cp.revealedAt);
      if (forbiddenAnnouncedAtSeen !== at){
        forbiddenAnnouncedAtSeen = at;
        showAnnounce('みてはいけないもの公開！');
      }
    }

    if (latestPlayers.length) renderAll(latestPlayers);
  });
}

async function maybeTriggerForbiddenCenter(index){
  if (!state.roomCode) return;

  // すでに公開済なら何もしない
  if (state.centerPublic && state.centerPublic.cardName === FORBIDDEN_CARD_NAME) return;
  if (state.room && state.room.mitenaikeTriggeredAt) return;

  const center = (state.room && Array.isArray(state.room.centerCards)) ? state.room.centerCards : [];
  const card = (index != null && center[index] != null) ? String(center[index]) : null;
  if (card !== FORBIDDEN_CARD_NAME) return;

  // 現在のタイマー設定を使って「残り1秒」になるよう startAt を巻き戻す
  const durationSec = Number(state.timer?.durationSec ?? getConfiguredDurationSec());
  if (!Number.isFinite(durationSec) || durationSec <= 1) return;

  const now = Date.now();
  const newStartAt = now - (durationSec - 1) * 1000;

  // multi-location update（同時更新）
  const updates = {};
  updates[`rooms/${state.roomCode}/centerPublic`] = {
    index: Number(index),
    cardName: FORBIDDEN_CARD_NAME,
    revealedAt: now,
    byPlayerId: state.userId
  };
  updates[`rooms/${state.roomCode}/timer`] = {
    startAt: newStartAt,
    durationSec
  };
  updates[`rooms/${state.roomCode}/mitenaikeTriggeredAt`] = now;

  await update(ref(db), updates);
}

/* ===== 投票 ===== */
function subscribeVotes(){
  onValue(ref(db, `rooms/${state.roomCode}/votes`), snap => {
    state.votes = snap.val() || {};
    if (latestPlayers.length) renderAll(latestPlayers);
    maybeHostFinalizeVote(latestPlayers);
  });
}
function getMyVoteTargetId(){
  const v = state.votes && state.votes[state.userId];
  return v?.targetPlayerId ? String(v.targetPlayerId) : null;
}
function haveIVoted(){ return !!getMyVoteTargetId(); }
function isMeSeated(){
  return Number.isInteger(state.seatedTable) && state.seatedTable >= 1;
}

function isFoxSeenByOther(playerId){
  const pid = String(playerId);
  const hand = state.hands && state.hands[pid];
  const cardName = (hand && Array.isArray(hand.cards) && hand.cards[0]) ? String(hand.cards[0]) : null;
  if (cardName !== 'きつね') return false;

  const pr = getPublicRevealFor(pid);
  return !!(pr && pr.byPlayerId && String(pr.byPlayerId) !== pid);
}
function canPlayerVote(playerId){
  const pid = String(playerId);
  const seated = latestPlayers.some(p => String(p.id) === pid);
  if (!seated) return false;
  return !isFoxSeenByOther(pid);
}
function canPlayerBeVoteTarget(playerId){
  return !isFoxSeenByOther(playerId);
}

function isVotingOpenNow(){
  const t = state.timer;
  if (!t || !t.startAt || !t.durationSec) return false;
  const startAt = Number(t.startAt);
  const durationSec = Number(t.durationSec);
  const openAt = startAt + durationSec*1000 + VOTE_POP_MS;
  return Date.now() >= openAt;
}

function areAllVoted(players){
  if (!players || !players.length) return false;
  const voterIds = new Set(players.map(p => p.id).filter(id => canPlayerVote(id)));
  if (!voterIds.size) return false;
  const votes = state.votes || {};
  for (const id of voterIds){
    if (!votes[id] || !votes[id].targetPlayerId) return false;
  }
  return true;
}
function computeVoteCounts(players){
  const counts = {};
  (players || []).forEach(p => { counts[p.id] = 0; });
  const votes = state.votes || {};
  for (const [voterId, val] of Object.entries(votes)){
    if (!val || !val.targetPlayerId) continue;
    const tid = String(val.targetPlayerId);
    if (!(tid in counts)) counts[tid] = 0;
    counts[tid] += 1;
  }
  return counts;
}
function computeWinnersFromCounts(players, counts){
  const normalizedPlayers = (players || []).map(p => ({ ...p, id: String(p.id) }));
  const ids = normalizedPlayers.map(p => p.id);
  const handMap = {};
  ids.forEach(id => {
    const hand = state.hands && state.hands[id];
    handMap[id] = (hand && Array.isArray(hand.cards) && hand.cards[0]) ? String(hand.cards[0]) : null;
  });

  let max = -1;
  ids.forEach(id => { max = Math.max(max, Number(counts?.[id] ?? 0)); });
  const mostVotedIds = ids.filter(id => Number(counts?.[id] ?? 0) === max);

  const idsByCard = (cardName) => ids.filter(id => handMap[id] === String(cardName));
  const winnerSet = new Set();

  const foxIds = idsByCard('きつね');
  const uranaishiIds = new Set(idsByCard('うらないし'));
  const roshutsuIds = idsByCard('ろしゅつきょう');
  const ushiIds = idsByCard('うし');
  const wolfIds = idsByCard('おおかみ');
  const kyoujinIds = idsByCard('きょうじん');
  const villagerTeamIds = [
    ...idsByCard('むらびと'),
    ...idsByCard('うらないし'),
    ...idsByCard('れいばいし'),
    ...idsByCard('ごえい')
  ];

  roshutsuIds.forEach(pid => {
    const pr = getPublicRevealFor(pid);
    const byOther = !!(pr && pr.byPlayerId && String(pr.byPlayerId) !== String(pid));
    if (byOther) winnerSet.add(pid);
  });

  ushiIds.forEach(pid => {
    if (Number(counts?.[pid] ?? 0) >= 1) winnerSet.add(pid);
  });

  let foxWon = false;
  foxIds.forEach(pid => {
    const pr = getPublicRevealFor(pid);
    const seenByOther = !!(pr && pr.byPlayerId && String(pr.byPlayerId) !== String(pid));
    const foxVoteTarget = state.votes?.[pid]?.targetPlayerId ? String(state.votes[pid].targetPlayerId) : null;
    const votedUranaishi = !!(foxVoteTarget && uranaishiIds.has(foxVoteTarget));
    const foxIsMostVoted = mostVotedIds.includes(pid);

    if (!seenByOther && !votedUranaishi && !foxIsMostVoted){
      winnerSet.add(pid);
      foxWon = true;
    }
  });

  let wolfTeamWon = false;
  let kyoujinOnlyWon = false;

  if (!foxWon && wolfIds.length > 0){
    const wolfIsMostVoted = wolfIds.some(pid => mostVotedIds.includes(pid));
    if (!wolfIsMostVoted){
      wolfIds.forEach(pid => winnerSet.add(pid));
      kyoujinIds.forEach(pid => winnerSet.add(pid));
      wolfTeamWon = true;
    }
  }

  if (!foxWon && wolfIds.length === 0 && kyoujinIds.length > 0){
    const kyoujinIsMostVoted = kyoujinIds.some(pid => mostVotedIds.includes(pid));
    if (!kyoujinIsMostVoted){
      kyoujinIds.forEach(pid => winnerSet.add(pid));
      kyoujinOnlyWon = true;
    }
  }

  if (!foxWon && !wolfTeamWon && !kyoujinOnlyWon){
    villagerTeamIds.forEach(pid => winnerSet.add(pid));
  }

  return Array.from(winnerSet);
}
async function setMyVote(targetPlayerId){
  if (!state.roomCode) return;
  if (!isMeSeated()) return;
  if (!canPlayerVote(state.userId)) return;
  if (!canPlayerBeVoteTarget(targetPlayerId)) return;
  if (haveIVoted()) return;
  if (!isVotingOpenNow()) return;
  await set(ref(db, `rooms/${state.roomCode}/votes/${state.userId}`), {
    targetPlayerId: String(targetPlayerId),
    votedAt: Date.now()
  });
}

async function maybeHostFinalizeVote(players){
  if (!state.isHost) return;
  if (!players || !players.length) return;
  if (!areAllVoted(players)) return;

  const room = state.room || {};
  if (room.voteDoneAt) return;

  const counts = computeVoteCounts(players);
  const winners = computeWinnersFromCounts(players, counts);

  await update(ref(db, `rooms/${state.roomCode}`), {
    voteDoneAt: Date.now(),
    voteCounts: counts,
    voteWinners: winners
  });
}

function openKickDialogForSeatSteal(targetPlayer){
  if (!targetPlayer) return;
  pendingSeatIndexToSteal = Number(targetPlayer.seatIndex);
  pendingSeatPlayerIdToSteal = String(targetPlayer.id);
  kickMessage.textContent = `「${targetPlayer.name || '名無し'}」を追い出して、着席しますか？`;
  kickDialog.classList.remove('hidden');
}
function closeKickDialog(){
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
}

async function stealSeatWithStateTransfer(){
  if (!state.roomCode) return;
  if (!Number.isInteger(pendingSeatIndexToSteal) || pendingSeatIndexToSteal < 1) return;

  const seatIndex = Number(pendingSeatIndexToSteal);
  const oldPlayerId = pendingSeatPlayerIdToSteal ? String(pendingSeatPlayerIdToSteal) : null;
  if (!oldPlayerId || oldPlayerId === state.userId) return;

  const rootSnap = await get(ref(db, `rooms/${state.roomCode}`));
  const roomData = rootSnap.val() || {};
  const seatNow = roomData.tables?.[seatIndex] || null;
  if (!seatNow || String(seatNow.playerId) !== oldPlayerId) return;

  const updates = {};

  if (isMeSeated()){
    updates[`rooms/${state.roomCode}/tables/${state.seatedTable}`] = null;
  }

  updates[`rooms/${state.roomCode}/tables/${seatIndex}`] = {
    playerId: state.userId,
    playerName: state.userName || '名無し'
  };

  const copyNodes = [
    'hands',
    'bubbles',
    'reibaishiPicks',
    'goeiPicks',
    'uranaishiPicks',
    'votes',
    'publicReveals'
  ];

  copyNodes.forEach(node => {
    const fromVal = roomData?.[node]?.[oldPlayerId];
    const toPath = `rooms/${state.roomCode}/${node}/${state.userId}`;
    const fromPath = `rooms/${state.roomCode}/${node}/${oldPlayerId}`;

    if (fromVal != null){
      updates[toPath] = fromVal;
    }
    updates[fromPath] = null;
  });

  const votesAll = roomData?.votes || {};
  Object.entries(votesAll).forEach(([voterId, voteVal]) => {
    if (!voteVal || !voteVal.targetPlayerId) return;
    if (String(voteVal.targetPlayerId) !== oldPlayerId) return;
    updates[`rooms/${state.roomCode}/votes/${voterId}/targetPlayerId`] = state.userId;
  });

  const goeiAll = roomData?.goeiPicks || {};
  Object.entries(goeiAll).forEach(([pickerId, pickVal]) => {
    if (!pickVal || !pickVal.targetPlayerId) return;
    if (String(pickVal.targetPlayerId) !== oldPlayerId) return;
    updates[`rooms/${state.roomCode}/goeiPicks/${pickerId}/targetPlayerId`] = state.userId;
  });

  const uranaiAll = roomData?.uranaishiPicks || {};
  Object.entries(uranaiAll).forEach(([pickerId, pickVal]) => {
    if (!pickVal || !pickVal.targetPlayerId) return;
    if (String(pickVal.targetPlayerId) !== oldPlayerId) return;
    updates[`rooms/${state.roomCode}/uranaishiPicks/${pickerId}/targetPlayerId`] = state.userId;
  });

  await update(ref(db), updates);

  state.seatedTable = seatIndex;
  seatPop.classList.add('hidden');
}

function hideVoteResultOverlay(){
  voteResultOverlay.classList.remove('visible');
  voteResultRow.innerHTML = '';
}

function buildCardWithOptionalLoss(cardName, isLoser){
  const base = buildCardImg(cardImgSrcByName(cardName), cardName);
  if (!isLoser) return base;

  const wrap = document.createElement('div');
  wrap.className = 'card-loss-wrap';

  const crack = buildCardImg('hibi.png', 'hibi');
  crack.className = 'loss-crack';

  wrap.appendChild(crack);
  wrap.appendChild(base);
  return wrap;
}

function getVoteWinnerIds(players){
  if (state.room && Array.isArray(state.room.voteWinners) && state.room.voteWinners.length){
    return state.room.voteWinners.map(String);
  }
  const counts = (state.room && state.room.voteCounts) ? state.room.voteCounts : computeVoteCounts(players || latestPlayers || []);
  return computeWinnersFromCounts(players || latestPlayers || [], counts).map(String);
}

/* ===== 役職判定 ===== */
function getRoleOf(playerId){
  const b = state.bubbles && state.bubbles[playerId];
  return (b && b.text) ? b.text : null;
}
function getMyRole(){ return getRoleOf(state.userId); }

function getMyHandCardName(){
  const h = state.hands && state.hands[state.userId];
  const v = (h && Array.isArray(h.cards) && h.cards.length) ? h.cards[0] : null;
  return v ? String(v) : null;
}

const ROLE_PICK_BLOCK_CARDS = ['むらびと'];
const ROLE_ONLY_IF_HAND_IS = ['うらないし','れいばいし','ごえい'];

function canOpenRolePickerFromMyCard(){
  if (!state.roomCode) return false;
  if (!joinBox.classList.contains('hidden')) return false;
  if (isVotingOpenNow()) return false;
  if (getMyRole()) return false;

  const myCard = getMyHandCardName();
  if (!myCard) return false;

  if (ROLE_PICK_BLOCK_CARDS.includes(myCard)) return false;

  return true;
}

function applyRolePickerConstraints(){
  const myCard = getMyHandCardName();
  const onlyRole = ROLE_ONLY_IF_HAND_IS.includes(myCard) ? myCard : null;

  rolePickerBackdrop.querySelectorAll('.role-btn[data-role]').forEach(btn => {
    const role = btn.getAttribute('data-role');
    const disable = onlyRole ? (role !== onlyRole) : false;

    btn.classList.toggle('disabled', disable);
    btn.setAttribute('aria-disabled', disable ? 'true' : 'false');
  });
}

function openRolePicker(){
  if (!canOpenRolePickerFromMyCard()) return;
  if (rolePickerOpen) return;

  applyRolePickerConstraints();
  rolePickerOpen = true;
  rolePickerBackdrop.classList.remove('hidden');
}
function closeRolePicker(){
  rolePickerOpen = false;
  rolePickerBackdrop.classList.add('hidden');
}
const btnRoleCancel2 = document.getElementById('btnRoleCancel');
btnRoleCancel2.addEventListener('click', closeRolePicker);
rolePickerBackdrop.addEventListener('click', (e) => { if (e.target === rolePickerBackdrop) closeRolePicker(); });

rolePickerBackdrop.querySelectorAll('.role-btn[data-role]').forEach(btn => {
  btn.addEventListener('click', async () => {
    if (btn.classList.contains('disabled')) return;
    const role = btn.getAttribute('data-role');
    await setMyBubble(role);
    closeRolePicker();
  });
});

function subscribeRoom(){
  onValue(ref(db, `rooms/${state.roomCode}`), snap => {
    const roomData = snap.val() || {};
    state.room = roomData;

    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
    if (latestPlayers.length) renderAll(latestPlayers);

    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();

    const startedAt = roomData.startedAt ? Number(roomData.startedAt) : null;
    if (startedAt && startedAt !== lastStartedAtSeen){
      lastStartedAtSeen = startedAt;
      voteAnnouncedForStartAt = null;
      lastVoteDoneAtSeen = null;
      hideVoteResultOverlay();
      forbiddenAnnouncedAtSeen = null; // ✅ 追加
      showAnnounce('議論開始！');
    }

    const voteDoneAt = roomData.voteDoneAt ? Number(roomData.voteDoneAt) : null;
    if (voteDoneAt && voteDoneAt !== lastVoteDoneAtSeen){
      lastVoteDoneAtSeen = voteDoneAt;
      hideVoteResultOverlay();

      setTimeout(() => { if (latestPlayers.length) renderAll(latestPlayers); }, 0);
    }
  });
}
function subscribeHostState(){
  onValue(ref(db, `rooms/${state.roomCode}/hostId`), snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}
function subscribeHands(){
  onValue(ref(db, `rooms/${state.roomCode}/hands`), snap => {
    state.hands = snap.val() || {};
    renderHandsOnly();
    if (latestPlayers.length) renderAll(latestPlayers);
  });
}

function getMyReibaishiPickIndex(){
  const p = state.reibaishiPicks && state.reibaishiPicks[state.userId];
  return (p && Number.isInteger(p.index)) ? p.index : null;
}
function getMyGoeiPickTargetId(){
  const g = state.goeiPicks && state.goeiPicks[state.userId];
  return (g && g.targetPlayerId) ? g.targetPlayerId : null;
}
function getMyUranaishiPickTargetId(){
  const u = state.uranaishiPicks && state.uranaishiPicks[state.userId];
  return (u && u.targetPlayerId) ? u.targetPlayerId : null;
}

function isMeReibaishi(){ return getMyRole() === 'れいばいし'; }
function isMeGoei(){ return getMyRole() === 'ごえい'; }
function isMeUranaishi(){ return getMyRole() === 'うらないし'; }

function canMePickCenterNow(){
  const center = (state.room && Array.isArray(state.room.centerCards)) ? state.room.centerCards : [];
  return isMeReibaishi() && getMyReibaishiPickIndex() === null && center.length >= 3;
}
function canMePickGoeiNow(){
  return isMeGoei() && !getMyGoeiPickTargetId();
}
function canMePickUranaishiNow(){
  return isMeUranaishi() && !getMyUranaishiPickTargetId();
}

function isMyIdentityRevealedByEffect(){
  const pr = getPublicRevealFor(state.userId);
  if (!pr) return false;
  if (!GLOBAL_REVEAL_CARDS.has(String(pr.cardName))) return false;
  const by = pr.byPlayerId ? String(pr.byPlayerId) : null;
  if (!by) return false;
  return by !== state.userId;
}

/* ===== 手札描画（画像） ===== */
function renderMyHand(){
  myHandEl.innerHTML = '';
  const handData = state.hands[state.userId];
  if (!handData || !Array.isArray(handData.cards)) return;

  const voteDone = !!(state.room && state.room.voteDoneAt);
  const myPublic = getPublicRevealFor(state.userId);
  const winnerSet = voteDone ? new Set(getVoteWinnerIds(latestPlayers).map(String)) : new Set();
  const isLoserAfterVote = voteDone && !winnerSet.has(String(state.userId));

  handData.cards.forEach(v => {
    const card = document.createElement('div');
    card.className = 'my-card';
    card.setAttribute('data-my-card', '1');

    const nameToShow = myPublic ? String(myPublic.cardName) : String(v);
    card.appendChild(buildCardWithOptionalLoss(nameToShow, isLoserAfterVote));

    if (isMyIdentityRevealedByEffect()){
      card.classList.add('public-revealed-outline');

      const at = Number(myPublic?.revealedAt ?? 0);
      if (myPublic && myPublicOutlineSeen[state.userId] !== at){
        myPublicOutlineSeen[state.userId] = at;
        card.classList.add('global-reveal-bounce');
        setTimeout(()=>card.classList.remove('global-reveal-bounce'), 650);
      }
    }

    if (myPublic){
      const seen = revealBounceSeen[state.userId];
      if (seen !== Number(myPublic.revealedAt)){
        revealBounceSeen[state.userId] = Number(myPublic.revealedAt);

        card.classList.add('reveal-bounce');
        setTimeout(()=>card.classList.remove('reveal-bounce'), 520);

        const nm = String(myPublic.cardName);
        if (GLOBAL_REVEAL_CARDS.has(nm)){
          const seen2 = globalSpecialBounceSeen[state.userId];
          if (seen2 !== Number(myPublic.revealedAt)){
            globalSpecialBounceSeen[state.userId] = Number(myPublic.revealedAt);
            card.classList.add('global-reveal-bounce');
            setTimeout(()=>card.classList.remove('global-reveal-bounce'), 650);
          }
        }
      }
    }

    card.addEventListener('click', (e) => {
      e.stopPropagation();
      if (isVotingOpenNow()) return;
      if (voteDone) return;
      if (myPublic) return;
      openRolePicker();
    });

    myHandEl.appendChild(card);
  });
}
function renderHandsOnly(){
  renderMyHand();
  drawGlobalArrows();
}
function renderHands(){
  renderHandsOnly();
  if (latestPlayers.length) renderAll(latestPlayers);
}

/* ===== URL room ===== */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), { name: state.userName, joinedAt: Date.now() });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');
  updateRoleGuidePopVisibility();

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeBubbles();
  subscribeReibaishiPicks();
  subscribeGoeiPicks();
  subscribeUranaishiPicks();
  subscribeVotes();
  subscribeTimer();
  subscribeTimerConfig();
  subscribePublicReveals();
  subscribeDeckOverrides();

  // ✅ 追加：センター公開購読
  subscribeCenterPublic();

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* ===== 着席UI ===== */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){ seatPop.classList.add('hidden'); return; }
  if (state.seatedTable !== null){ seatPop.classList.add('hidden'); return; }

  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=3; i<=9; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;
        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          await set(ref(db, `rooms/${state.roomCode}/tables/1`), { playerId: state.userId, playerName: state.userName });
          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 9;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        await set(ref(db, `rooms/${state.roomCode}/tables/${i}`), { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

btnKickNo.addEventListener('click', () => {
  closeKickDialog();
});
btnKickYes.addEventListener('click', async () => {
  try {
    await stealSeatWithStateTransfer();
  } finally {
    closeKickDialog();
  }
});
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) closeKickDialog();
});

/* ===== プレイヤー購読 ===== */
function subscribePlayers(){
  onValue(ref(db, `rooms/${state.roomCode}/tables`), async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? { id: t.playerId, name: t.playerName || '名無し', seatIndex: Number(seatIndex) } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) { state.seatedTable = mySeat.seatIndex; seatPop.classList.add('hidden'); }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) state.seatedTable = null;

    await syncSeatUI();
    renderAll(players);
    maybeHostFinalizeVote(players);
  });
}

/* ===== センター3枚（画像） ===== */
function renderCenterCardsInto(container){
  const center = (state.room && Array.isArray(state.room.centerCards)) ? state.room.centerCards : [];
  const wrap = document.createElement('div');
  wrap.className = 'center-cards';
  const hasAnyReibaishiPick = !!Object.keys(state.reibaishiPicks || {}).length;

  const iPicked = getMyReibaishiPickIndex();
  const canPick = canMePickCenterNow();

  const voteDone = !!(state.room && state.room.voteDoneAt);
  const votingOpen = isVotingOpenNow();

  if (!voteDone && !votingOpen){
    if (isMeReibaishi() && iPicked === null) wrap.classList.add('reibai-pulsing');
    if (canPick) wrap.classList.add('selectable');
  }

  for(let i=0;i<3;i++){
    const c = document.createElement('div');
    c.className = 'center-card';
    c.setAttribute('data-center-index', String(i));

    // ✅ 追加：センター公開（みてはいけないもの）は全員に表
    const cp = state.centerPublic;
    const forceShowForbidden =
      !!(cp && cp.cardName === FORBIDDEN_CARD_NAME && Number(cp.index) === i && center[i] != null);

    const shouldShowFrontForReibaishiPick =
      (!voteDone && !votingOpen && isMeReibaishi() && iPicked === i && center[i] != null);

    if (voteDone && center[i] != null){
      c.appendChild(buildCardImg(cardImgSrcByName(center[i]), String(center[i])));
    } else if (hasAnyReibaishiPick && center[i] != null){
      c.appendChild(buildCardImg(cardImgSrcByName(center[i]), String(center[i])));
    } else if (forceShowForbidden){
      c.appendChild(buildCardImg(cardImgSrcByName(center[i]), String(center[i])));
    } else if (shouldShowFrontForReibaishiPick){
      c.appendChild(buildCardImg(cardImgSrcByName(center[i]), String(center[i])));
    } else {
      c.appendChild(buildCardImg(BACK_IMAGE, 'back'));
    }

    if (!voteDone && !votingOpen && canPick) {
      c.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!canMePickCenterNow()) return;
        await setMyReibaishiPick(i);
      }, { passive: true });
    }

    wrap.appendChild(c);
  }

  container.appendChild(wrap);
}

/* ===== ヘルプ ===== */
function createCountBadge(n){
  const b = document.createElement('div');
  b.className = 'count-badge';
  b.textContent = String(n);
  return b;
}

/* ✅ 追加：説明欄作成 */
function createHelpDesc(text, colStart, colEnd){
  const d = document.createElement('div');
  d.className = 'help-desc';
  d.textContent = text;
  d.style.gridColumn = `${colStart} / ${colEnd}`;
  return d;
}

function renderHelpList(){
  helpBody.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'help-grid';

  const addCard = (name) => {
    const c = document.createElement('div');
    c.className = 'help-card';
    c.setAttribute('data-card-name', name);

    const cnt = getEffectiveCountNow(name);
    if (cnt <= 0) c.classList.add('dim');

    // ①：枚数タグは「むらびと」「おおかみ」だけ
    if (VARIABLE_COUNT_CARDS.has(name)){
      c.appendChild(createCountBadge(cnt));
    }

    if (state.isHost){
      c.classList.add('host-toggle');
      c.addEventListener('click', async (e) => {
        e.stopPropagation();

        if (VARIABLE_COUNT_CARDS.has(name)){
          const current = clampInt(getEffectiveCountNow(name), 0, 3);
          const next = (current + 1) % 4;
          await setDeckOverride(name, next);
          return;
        }

        const nowEnabled = isCardEnabledNow(name);
        await setDeckOverride(name, !nowEnabled);
      });
    }

    c.appendChild(buildCardImg(cardImgSrcByName(name), name));
    grid.appendChild(c);
  };

  // 1行目（1〜5枚目）
  const row1 = ALL_CARDS.slice(0, 5);
  row1.forEach(addCard);

  grid.appendChild(createHelpDesc('・「おおかみ」が一匹でも追放できていること。\n・「おおかみ」がいなければ「きょうじん」を追放できていること。\n・「きつね」が生存していないこと。', 1, 5));
  grid.appendChild(createHelpDesc('・追放されず、1票以上投票されていること', 5, 6));

  // 2行目（6〜10枚目）
  const row2 = ALL_CARDS.slice(5, 10);
  row2.forEach(addCard);

  grid.appendChild(createHelpDesc('・投票でおおかみが1匹も追放されていないこと\n・場におおかみが1匹もいなかった場合はきょうじんが追放されていないこと\n・プレイヤーの中にきつねが生存していないこと', 1, 4));

  const a = row2[2], b = row2[3], c2 = row2[4];
  grid.appendChild(createHelpDesc(`・追放されず残っていること。占われたら即公開で負け。`, 4, 4));
  grid.appendChild(createHelpDesc(`・カードを見られたら即公開で勝ち`, 5, 6));

  if (state.isHost){
    // タイマー設定カード（最後）
    const timerCard = document.createElement('div');
    timerCard.className = 'help-card timer-card';
    timerCard.innerHTML = `
      <div class="timer-title">タイマー設定</div>
      <div class="timer-buttons">
        <button class="tbtn" type="button" data-timer-sec="6">2:00</button>
        <button class="tbtn" type="button" data-timer-sec="150">2:30</button>
        <button class="tbtn" type="button" data-timer-sec="180">3:00</button>
      </div>
      <div class="timer-note">※次の開始に反映</div>
    `;
    grid.appendChild(timerCard);

    timerCard.querySelectorAll('[data-timer-sec]').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const sec = Number(btn.getAttribute('data-timer-sec'));
        await setTimerDurationSec(sec);
        syncHelpTimerSelectionUI();
      });
    });
  }

  helpBody.appendChild(grid);
  syncHelpTimerSelectionUI();
}

function openHelp(){ renderHelpList(); helpBackdrop.classList.remove('hidden'); }
function closeHelp(){ helpBackdrop.classList.add('hidden'); }
helpBtn.addEventListener('click', () => { if (joinBox.classList.contains('hidden')) openHelp(); });
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

/* ===== グローバル矢印 ===== */
function clearGlobalArrows(){
  while (globalArrowLayer.firstChild) globalArrowLayer.removeChild(globalArrowLayer.firstChild);
}
function ensureArrowDefs(svg){
  svg.setAttribute('width', String(window.innerWidth));
  svg.setAttribute('height', String(window.innerHeight));
  svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);

  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', 'arrowHeadGlobal');
  marker.setAttribute('markerWidth', '10');
  marker.setAttribute('markerHeight', '10');
  marker.setAttribute('refX', '8');
  marker.setAttribute('refY', '3');
  marker.setAttribute('orient', 'auto');
  marker.setAttribute('markerUnits', 'strokeWidth');

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M0,0 L8,3 L0,6 Z');
  path.setAttribute('fill', '#111');
  marker.appendChild(path);

  defs.appendChild(marker);
  svg.appendChild(defs);
}
function centerOfRect(r){ return { x:(r.left+r.right)/2, y:(r.top+r.bottom)/2 }; }
function line(svg, a, b){
  const ln = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  ln.setAttribute('x1', String(a.x));
  ln.setAttribute('y1', String(a.y));
  ln.setAttribute('x2', String(b.x));
  ln.setAttribute('y2', String(b.y));
  ln.setAttribute('stroke', '#111');
  ln.setAttribute('stroke-width', '2');
  ln.setAttribute('stroke-dasharray', '5 5');
  ln.setAttribute('marker-end', 'url(#arrowHeadGlobal)');
  ln.setAttribute('opacity', '0.9');
  svg.appendChild(ln);
}
function topCenterOfRect(r){ return { x:(r.left+r.right)/2, y:r.top }; }

function drawGlobalArrows(){
  if (!state.roomCode) return;

  const voteDone = !!(state.room && state.room.voteDoneAt);
  if (voteDone || isVotingOpenNow()){
    clearGlobalArrows();
    return;
  }

  clearGlobalArrows();
  ensureArrowDefs(globalArrowLayer);

  const picksR = state.reibaishiPicks || {};
  for (const [pickerId, val] of Object.entries(picksR)){
    if (!val || !Number.isInteger(val.index)) continue;
    const idx = val.index;
    if (idx < 0 || idx > 2) continue;
    if (pickerId === state.userId) continue;

    const from = document.querySelector(`.player-tag[data-player-id="${CSS.escape(pickerId)}"]`);
    const to   = document.querySelector(`.center-card[data-center-index="${idx}"]`);
    if (!from || !to) continue;

    line(globalArrowLayer, centerOfRect(from.getBoundingClientRect()), centerOfRect(to.getBoundingClientRect()));
  }

  const picksG = state.goeiPicks || {};
  for (const [pickerId, val] of Object.entries(picksG)){
    if (!val || !val.targetPlayerId) continue;
    if (pickerId === state.userId) continue;

    const fromTag = document.querySelector(`.player-tag[data-player-id="${CSS.escape(pickerId)}"]`);
    if (!fromTag) continue;

    const targetId = val.targetPlayerId;

    if (targetId === state.userId){
      const myCard = document.querySelector('.my-card[data-my-card="1"]');
      if (!myCard) continue;

      line(globalArrowLayer, centerOfRect(fromTag.getBoundingClientRect()), topCenterOfRect(myCard.getBoundingClientRect()));
      continue;
    }

    const targetCard = document.querySelector(`.player-tag[data-player-id="${CSS.escape(targetId)}"] .mini-card`);
    if (!targetCard) continue;

    line(globalArrowLayer, centerOfRect(fromTag.getBoundingClientRect()), centerOfRect(targetCard.getBoundingClientRect()));
  }

  const picksU = state.uranaishiPicks || {};
  for (const [pickerId, val] of Object.entries(picksU)){
    if (!val || !val.targetPlayerId) continue;
    if (pickerId === state.userId) continue;

    const fromTag = document.querySelector(`.player-tag[data-player-id="${CSS.escape(pickerId)}"]`);
    if (!fromTag) continue;

    const targetId = val.targetPlayerId;

    if (targetId === state.userId){
      const myCard = document.querySelector('.my-card[data-my-card="1"]');
      if (!myCard) continue;

      line(globalArrowLayer, centerOfRect(fromTag.getBoundingClientRect()), topCenterOfRect(myCard.getBoundingClientRect()));
      continue;
    }

    const targetCard = document.querySelector(`.player-tag[data-player-id="${CSS.escape(targetId)}"] .mini-card`);
    if (!targetCard) continue;

    line(globalArrowLayer, centerOfRect(fromTag.getBoundingClientRect()), centerOfRect(targetCard.getBoundingClientRect()));
  }
}

window.addEventListener('resize', drawGlobalArrows);

/* ===== プレイヤー円描画 ===== */
function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  renderCenterCardsInto(playerCircle);

  const n = players.length;
  const radius = 65;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  const votingOpen = isVotingOpenNow();
  const voteDone = !!(state.room && state.room.voteDoneAt);
  const allVoted = areAllVoted(players);
  const iVoted = haveIVoted();
  const iCanVote = canPlayerVote(state.userId);
  const myVoteTarget = getMyVoteTargetId();

  const voteCounts = (voteDone || allVoted) ? (state.room.voteCounts || computeVoteCounts(players)) : null;
  const voteWinnerSet = (voteDone || allVoted) ? new Set(getVoteWinnerIds(players).map(String)) : new Set();

  const myGoeiTarget = getMyGoeiPickTargetId();
  const goeiCanPick  = (!votingOpen && !voteDone) && canMePickGoeiNow();

  const myUranaiTarget = getMyUranaishiPickTargetId();
  const uranaiCanPick  = (!votingOpen && !voteDone) && canMePickUranaishiNow();

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;
    tag.setAttribute('data-player-id', p.id);

    if (!isMeSeated() && p.id !== state.userId){
      tag.addEventListener('click', () => {
        openKickDialogForSeatSteal(p);
      });
    }

    const b = state.bubbles && state.bubbles[p.id];
    const shouldShowBubble = !(voteDone || allVoted);
    if (shouldShowBubble && b && b.text){
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      bubble.textContent = b.text;
      tag.appendChild(bubble);
    }

    if (voteDone || allVoted){
      const c = Number(voteCounts?.[p.id] ?? 0);
      if (c > 0){
        const badge = document.createElement('div');
        badge.className = 'envelope-badge';
        badge.textContent = '✉'.repeat(Math.min(20, c));
        tag.appendChild(badge);
      }
    } else {
      if (iVoted && myVoteTarget === p.id){
        const badge = document.createElement('div');
        badge.className = 'envelope-badge';
        badge.textContent = '✉';
        tag.appendChild(badge);
      }
    }

    if (iVoted && p.id !== state.userId){
      const otherVoted = !!(state.votes && state.votes[p.id] && state.votes[p.id].targetPlayerId);
      if (otherVoted) tag.classList.add('voted-dim');
    }

    const handData = state.hands[p.id];
    const pub = getPublicRevealFor(p.id);

    if (p.id !== state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const count = handData.cards.length;
      const spread = 70;
      const base = (count > 1) ? (-spread/2) : 0;

      const canVotePick = votingOpen
        && !voteDone
        && !allVoted
        && iCanVote
        && !iVoted
        && (p.id !== state.userId)
        && canPlayerBeVoteTarget(p.id);
      if (canVotePick){
        tag.classList.add('vote-pulsing', 'vote-selectable');
      }

      const targetHasRole = !!getRoleOf(p.id);

      const shouldPulseForGoei = (goeiCanPick && targetHasRole);
      const isMyPickedTargetGoei = (isMeGoei() && myGoeiTarget && myGoeiTarget === p.id);

      const shouldPulseForUranai = (uranaiCanPick && !targetHasRole);
      const isMyPickedTargetUranai = (isMeUranaishi() && myUranaiTarget && myUranaiTarget === p.id);

      if (!canVotePick){
        if (shouldPulseForGoei) tag.classList.add('goei-pulsing', 'goei-selectable');
        if (shouldPulseForUranai) tag.classList.add('uranai-pulsing', 'uranai-selectable');
      }

      if (isMyPickedTargetGoei){
        tag.classList.remove('goei-pulsing','goei-selectable');
      }
      if (isMyPickedTargetUranai){
        tag.classList.remove('uranai-pulsing','uranai-selectable');
      }

      handData.cards.forEach((v, idx2) => {
        const card = document.createElement('div');
        card.className = 'mini-card';

        const angleDeg = (count > 1) ? base + (spread/(count-1))*idx2 : 0;

        card.style.setProperty('--rot', `${angleDeg}deg`);
        card.style.zIndex = String(10 + idx2);

        let showFront = false;

        if (voteDone || allVoted) showFront = true;
        if (pub) showFront = true;

        if (!showFront){
          if (isMyPickedTargetGoei && idx2 === 0) showFront = true;
          if (isMyPickedTargetUranai && idx2 === 0) showFront = true;
        }

        if (showFront){
          const nameToShow = pub ? String(pub.cardName) : String(v);
          const isLoser = (voteDone || allVoted) && !voteWinnerSet.has(String(p.id));
          card.appendChild(buildCardWithOptionalLoss(nameToShow, isLoser));
        } else {
          card.appendChild(buildCardImg(BACK_IMAGE, 'back'));
        }

        if (canVotePick){
          card.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!isVotingOpenNow()) return;
            if (haveIVoted()) return;
            await setMyVote(p.id);
          }, { passive: true });
        }

        if (!canVotePick && shouldPulseForGoei){
          card.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!canMePickGoeiNow()) return;
            if (!getRoleOf(p.id)) return;
            await setMyGoeiPick(p.id);
          }, { passive: true });
        }

        if (!canVotePick && shouldPulseForUranai){
          card.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!canMePickUranaishiNow()) return;
            if (getRoleOf(p.id)) return;
            await setMyUranaishiPick(p.id);
          }, { passive: true });
        }

        miniHand.appendChild(card);
      });

      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  });

  drawGlobalArrows();
}

function renderAll(players){
  renderPlayerCircle(players);
  renderHandsOnly();
  drawGlobalArrows();
}

/* ===== スタート処理 ===== */
async function dealInitialHandsAndCenter(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const seated = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { seatIndex:Number(seatIndex), playerId:t.playerId } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  if (!seated.length) return;

  const deck = shuffleInPlace(buildDeck());

  const hands = {};
  seated.forEach(s => {
    const card = deck.shift();
    hands[s.playerId] = { cards: [card] };
  });

  const centerCards = [deck.shift(), deck.shift(), deck.shift()];

  const base = `rooms/${state.roomCode}`;
  await update(ref(db, base), { startedAt: Date.now(), centerCards, deckRemaining: deck.length });
  await set(ref(db, `${base}/hands`), hands);
}

/* ===== ホストUI ===== */
hostSettingsBtn.addEventListener('click', () => { if (state.isHost) startPop.classList.toggle('hidden'); });
btnStartPopClose.addEventListener('click', () => { startPop.classList.add('hidden'); });

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/centerCards`)),
    remove(ref(db, `${base}/startedAt`)),
    remove(ref(db, `${base}/deckRemaining`)),
    remove(ref(db, `${base}/bubbles`)),
    remove(ref(db, `${base}/reibaishiPicks`)),
    remove(ref(db, `${base}/goeiPicks`)),
    remove(ref(db, `${base}/uranaishiPicks`)),
    remove(ref(db, `${base}/votes`)),
    remove(ref(db, `${base}/voteDoneAt`)),
    remove(ref(db, `${base}/voteCounts`)),
    remove(ref(db, `${base}/voteWinners`)),
    remove(ref(db, `${base}/timer`)),
    remove(ref(db, `${base}/publicReveals`)),

    // ✅ 追加：みてはいけないもの公開状態もリセット
    remove(ref(db, `${base}/centerPublic`)),
    remove(ref(db, `${base}/mitenaikeTriggeredAt`)),
  ]);

  lastVoteDoneAtSeen = null;
  hideVoteResultOverlay();

  await dealInitialHandsAndCenter();
  await startConfiguredTimer();

  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/centerCards`)),
    remove(ref(db, `${base}/startedAt`)),
    remove(ref(db, `${base}/deckRemaining`)),
    remove(ref(db, `${base}/bubbles`)),
    remove(ref(db, `${base}/reibaishiPicks`)),
    remove(ref(db, `${base}/goeiPicks`)),
    remove(ref(db, `${base}/uranaishiPicks`)),
    remove(ref(db, `${base}/votes`)),
    remove(ref(db, `${base}/voteDoneAt`)),
    remove(ref(db, `${base}/voteCounts`)),
    remove(ref(db, `${base}/voteWinners`)),
    remove(ref(db, `${base}/timer`)),
    remove(ref(db, `${base}/publicReveals`)),
    remove(ref(db, `${base}/deckOverrides`)),

    // ✅ 追加：みてはいけないもの公開状態もリセット
    remove(ref(db, `${base}/centerPublic`)),
    remove(ref(db, `${base}/mitenaikeTriggeredAt`)),
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  lastVoteDoneAtSeen = null;
  hideVoteResultOverlay();

  await syncSeatUI();
  drawGlobalArrows();
});

/* ===== 画面離脱時 ===== */
window.addEventListener('beforeunload', () => {
  stopTimerTick();
  clearVoteOpenSchedule();
});
</script>

</body>
</html>


